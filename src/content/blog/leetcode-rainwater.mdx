---
title: "LeetCode Problem 42: Trapping Rain Water"
summary: "My (maybe) cooler solution to the trapping rainwater problem."
publishedAt: "2025-10-25T22:00:00"
lastUpdatedAt: "2025-10-26T00:00:00"
tags: ['leetcode', 'algorithms', 'problems']
---

# LeetCode Problem 42: Trapping Rain Water

To test how well the MDX rendering on my website is working, my first actual post
will be on my solution to [LeetCode Problem 42: Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/).
It's one of those problems that's hard to visualize, but relatively straightforward once
you see how it works.

## Problem Statement

> Given `n` non-negative integers representing an elevation map where the width of each bar is `1`,
> compute how much water it can trap after raining.
>
> **Example 1:**
> ![Elevation map](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)
> ```
> Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
> Output: 6
> Explanation: The above elevation map (black section) is represented by array  
> [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section)  
> are being trapped.
> ```
> **Example 2:**
> ```
> Input: height = [4,2,0,3,2,5]
> Output: 9
> ```
> **Constraints:**
> - `n == height.length`
> - `1 <= n <= 2 * 10^4`
> - `0 <= height[i] <= 10^5`

It's not immediately obvious, but this problem is a two-pointer problem.
You're given an array of heights, and you need to find out how much water can be trapped
between the heights. The key insight is that the amount of water that can be trapped
at any given point is determined by the minimum of the maximum heights to the left and right
of that point, minus the height at that point.

- For instance, if you look at point 3 (with a height of 0), to the left is a bar
  of height 1 and to the right, a bar of height 2. If you imagine pouring water
  into this structure, it would fill up to height 1 (the minimum of the two sides),
  before spilling over the left bar. Therefore, the amount of water that can be trapped
  at point 3 is $$\min(1, 2) - 0 = 1$$ unit of water.
- A two-pointer approach works well here to divide and conquer the problem, by
  calculating the trapped water from both sides towards the center. Each pointer
  keeps track of the previously seen maximum height, which is used to calculate
  the trapped water at each step.

## My Approach

For my approach, I used two instances of `std::accumulate`, one starting from
the left and one from the right. The two instances were split with a global
maximum height index, which allowed me to calculate the trapped water
from both sides. Technically, this solution is a "two-pointer" approach, I just
explicitly created the halves that would normally result from the
pointer movement. My solution also has some extra overhead from the STL algorithms
which slows it down, but I think it looks cool so ðŸ¤·.

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        auto globalMaxHeight = std::max_element(height.begin(), height.end());
        
        int currMaxHeight = 0;
        auto leftTrappedWater = std::accumulate(height.begin(), std::next(globalMaxHeight), 0, 
            [&](int acc, int e){
                currMaxHeight = std::max(e, currMaxHeight);
                return acc + (currMaxHeight - e);
            });

        currMaxHeight = 0;
        auto rightTrappedWater = std::accumulate(height.rbegin(), std::reverse_iterator(globalMaxHeight), 0, 
            [&](int acc, int e){
                currMaxHeight = std::max(e, currMaxHeight);
                return acc + (currMaxHeight - e);
            });

        return leftTrappedWater + rightTrappedWater;
    }
};
```

## The Popular C++ Solution

In comparison, here's the most popular solution by `niits`, who uses a "normal"
two-pointer approach like you're supposed to:

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int leftMax = height[left];
        int rightMax = height[right];
        int water = 0;

        while (left < right) {
            if (leftMax < rightMax) {
                left++;
                leftMax = max(leftMax, height[left]);
                water += leftMax - height[left];
            } else {
                right--;
                rightMax = max(rightMax, height[right]);
                water += rightMax - height[right];
            }
        }

        return water;        
    }
};
```

As you can see, significantly smaller, and without the extra overhead of the STL,
probably much faster as well. However, having `std::accumulate` in there with
the lambda functions makes it look "fancy" *You should never code for the*
*sake of making something look fancy, of course,* but I'm doing it here because
I can.

## Final Remarks

This problem is one of my favourites, mainly because the logic for the solution
is relatively straightforward, but the visualization of the problem in the way
they described it is trickier, and I have a bias towards these kinds of questions
(cuz I'm still bad at programming lol). I'd say "give the problem a try" and
you still should, but it does defeat the purpose after you've just read through
a solution.

I'm hoping to write more posts about LeetCode solutions in the future. Been meaning
to make a habit of doing these problems daily, but I pushed it off to the side
because life got busy. We shall see if I can get back into it.
